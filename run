#!/bin/sh

trap "exit" INT TERM ERR

config="$(mktemp)"
out_submission="$(mktemp)"
err_submission="$(mktemp)"
err_unittest="$(mktemp)"
err_linking="$(mktemp)"

cat > $config

language="$(jshon -e 'programming_language' -u < "$config")"
exercise_dir="$(jshon -e 'resources' -u < "$config")"
judge_dir="$(jshon -e 'judge' -u < "$config")"
workdir="$(jshon -e 'workdir' -u < "$config")"
hard_time_limit="$(jshon -e 'time_limit' -u < "$config")"
# Only use 90% of the time limit so there's still some time to generate a proper "timed-out" response
script_time_limit=$(echo $hard_time_limit | awk '{print int(0.9 * $1)}')
exercise_config=$exercise_dir/config.json

in_submission="submission.c"

o_submission_file="submission.o"
o_unittest_file="unittest.o"

output_executable="output"
output_aggregate="test_output_acc.json"
feedback="feedback.json"

LDFLAGS="-lgtest -lgtest_main"

# Check if given file contains g++ errors (e.g., lines containing the pattern " error: ").
# If so, provide feedback using these errors and exit script.
maybe_write_compiler_error()
{
	# $1 = name of the file containing the compiler errors
	# $2 = name of the file that was compiled
	if [ $(cat "$1" | grep " error: " -n | wc -l) -gt 0 ]; then
		python "$judge_dir/parse_compiler_errors.py" $1 $feedback
		cat $feedback
		exit 0
	fi
}

# Used for retrieving global or file-specific compiler & linker options from the test config.
get_file_specific_or_global_options()
{
	# $1 = name of the file to look up
	# $2 = name of the JSON field that specifies file-specific options
	# $3 = name of the JSON field that specifies the global options
	file_specific_options=$(cat $exercise_config 2> /dev/null | jshon -Q -e "$2" -e "$1" -u)
	if [ $file_specific_options ]; then
		echo $file_specific_options
	else
		# No options for the specific file were defined. Use the global option, if defined
		cat $exercise_config 2> /dev/null | jshon -Q -e "$3" -u
	fi
}
get_compiler_options()
{
	# $1 = name of the file that is to be compiled
	get_file_specific_or_global_options $1 "file_compiler_options" "global_compiler_options"
}
get_linker_options()
{
	# $1 = name of the unit test file for which an executable will be generated
	get_file_specific_or_global_options $1 "file_linker_options" "global_linker_options"
}

check_timeout()
{
	# Print default timeout feedback
	cat $judge_dir/timeout.json
	# Kill foreground process
	kill $$
	exit 0
}

cd "$workdir"

do_everything() {
	rm -rf ./*

	for file in "$exercise_dir"/*
	do
		if [ -f "$file" ]; then
			cp "$file" .
		fi
	done

	cat "$(jshon -e 'source' -u < "$config")" > "$in_submission"
	in_submission_cpp_options=$(get_compiler_options $in_submission)

	# Compile submission
	g++ -x c -c $in_submission_cpp_options -D main=__submission_main__ $in_submission -o $o_submission_file 2> $err_submission
	maybe_write_compiler_error $err_submission

	# Compile auxiliary files
	for aux_file in "$exercise_dir"/*.c
	do
		if [ -f "$aux_file" ]; then
			aux_file_compiler_options=$(get_compiler_options $aux_file)
			g++ -x c -c $aux_file_compiler_options $aux_file -o "aux_file_$(basename $aux_file).o"
		fi
	done

	idx=0
	for in_unittest in "$exercise_dir"/*.cpp
	do
		output_googletest="output_googletest_$idx.json"
		in_unittest_cpp_options=$(get_compiler_options $in_unittest)
		unittest_stdin_file=$(cat $exercise_config 2> /dev/null | jshon -Q -e "stdin_file" -e "$(basename $in_unittest)" -u)
		unittest_stdin_arg=$(cat $exercise_config 2> /dev/null | jshon -Q -e "stdin" -e "$(basename $in_unittest)" -u)
		if [ $unittest_stdin_file ]; then
			unittest_stdin=$(cat $unittest_stdin_file)
		else
			unittest_stdin=$unittest_stdin_arg
		fi
		unittest_command_line_args=$(cat $exercise_config 2> /dev/null | jshon -Q -e "command_line_args" -e "$(basename $in_unittest)" -u)
		g++ -std=c++11 -c $in_unittest_cpp_options "$in_unittest" -o "$o_unittest_file" 2> $err_unittest
		maybe_write_compiler_error $err_unittest
		extra_linker_options=$(get_linker_options $in_unittest)
		# Check that there actually are auxiliary files, since "shopt -s nullglob" doesn't seem to work
		if [ $(ls aux_file_*.o 2> /dev/null | wc -l) -gt 0 ]; then
			g++ aux_file_*.o $o_submission_file $o_unittest_file -o $output_executable $extra_linker_options $LDFLAGS -pthread 2> $err_linking
		else
			g++ $o_submission_file $o_unittest_file -o $output_executable $extra_linker_options $LDFLAGS -pthread 2> $err_linking
		fi
		maybe_write_compiler_error $err_linking
		# Run the executable: pipe stdin and pass command-line args
		echo $unittest_stdin | { ./$output_executable "--gtest_output=json:$(pwd)/$output_googletest" $unittest_command_line_args > /dev/null; } >& /dev/null
		idx=$((idx+1))
	done

	# Parse the (unexpected) output JSON files generated by the tests to generate the final feedback
	python "$judge_dir/parse_test_output.py" $feedback output_googletest_*.json unexpected_output_*.txt

	# Print feedback
	cat $feedback

	# Hard-kill the timeout subprocess before it prints a time-out error
	# kill -9 $TIMEOUT_CHECK 2> /dev/null
	exit 0
}

# ( sleep $script_time_limit ; check_timeout ) &
# TIMEOUT_CHECK=$!
do_everything
